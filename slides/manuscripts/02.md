# 原稿 #2

## 01

(とくになし)

## 02

今回やることはこの４つです。前回と比べるとだいぶしんどくなると思いますががんばりましょう。

第二回まで理解してしまえばおみくじアプリを作る分には何もこまらない程度にはSwiftがかけるようになると思います。

というわけでやっていきましょう。

## 03

まずはプロトコルです。
なんでしょうか。これ、覚えている人いますか？

Javaでインターフェースというワードを耳にしたことがあるひともいるかも知れませんが大体あれです。

## 04

Swiftでのプロトコルは実装するべきメソッドやフィールドを一覧にしたものです。
こいつらは実装自体は持ってません。実際に使うときはプロトコルを他のオブジェクトに適合させて使うことになります。

## 05

Objective-C時代にもプロトコルというものはあったのですが、あれとSwiftの構造体は別物です

Objective-C時代はメソッドだけしか持つことができなかったですが、フィールドも持つことができるようになりました。

あとは、プロトコルをクラスだけじゃなく構造体や列挙体にも適用することが可能になりました。

実は、Swiftではクラスの継承はあまり使用しません。プロトコルとExtensionをフル活用することで目的とするものがほとんど作れてしまうからです。

Extensionの話は第三回にするので楽しみにしててください

## 06

肝心のプロトコルに適合させる方法です。クラスにプロトコルを適合させる場合はこんな感じでできます。

構造体も列挙体もこんな感じでプロトコルに適合させることができます。構造体の話はこのあとすぐ出てきます

## 07

Objective-Cではあんまり出番がなかった構造体です

構造体は、色んな種類の値を１つの塊にまとめたものだというイメージを持ってもらえるといいのではないかと思います

イメージしづらいと思うので実際のコードを示します。

# 08

なんかクラス宣言とほとんど変わらないように見えますね。実際構造体とクラスの違いはほとんどありません。

Objective-C時代の構造体はメソッドを持つことができませんでしたが、Swiftでは持つことができます。

Swiftの構造体は、プロトコルに適合させることもできるようになっています。この場合はCarプロトコルに適合させていますね。

## 09

じゃあ構造体とクラスって何が違うんやって話です。

まず、クラスは既存のクラスを継承して新しいクラスを作ることができますが、構造体にそのような機能はありません。

それ以外にも違いがあります。

クラスは参照型で構造体は値型です。
なんかよくわからない概念が出てきましたね,,,

## 10

値型と参照型の違いは、変数に格納されているものの違いです。

値型の場合は値そのものが、参照型だと値の場所が格納されています。

## 11

値型と参照型、どれが値型でどれが参照型でしょうか。

構造体が値型でクラスが参照型であることを覚えておけば問題にはならないと思います。

ちなみに、配列やInt型、Double型やString型などおなじみの型は全部構造体でできてます。

Swiftの場合、あらゆるところで構造体が使われているんですが、どうしてなんでしょうか、クラスでだめなところがあるのでしょうか。

クラスで陥りがちな罠について説明します。

## 12

じゃあまずこの場合。

letでインスタンスを格納してますが、このletが固定しているのはインスタンスの参照であって、プロパティの値を固定しているわけじゃないです。

なのでプロパティの値を変更できてしまいます。

したの場合はインスタンスの参照自体を付け替えようとしているのでエラーになります。

こんな感じで意図せずインスタンスの中身が書き換えられてしまうことがあります

## 13

つぎもよく陥りがちな罠です

この場合はcar1とcar2でおんなじ場所を参照しているのでcar2のプロパティを書き換えるとcar1のプロパティまで書き換わっちゃうっていう事例です。

参照型の場合はこのように参照を共有してしまうケースがあります。意図してやっているのならまだしも、意図せずしてやってしまうとバグの原因になったりします。

## 14

じゃあ事故をどうやって防ぐかの話になります

もしクラスのインスタンスをどうしても受け渡ししなきゃいけない場合は、プロパティを全部読み取り専用にすれば安心です。

そしたら勝手に書き換えられることもなくなります。

もしくは、構造体で受け渡しをすればいいです。

構造体は値を受け渡す際に値自体がコピーされるので、参照が共有されることがないです。

ここでよく出てくる概念がmutableとimmutableです

## 15

知らなくてもなんとかなりはするのですが、JavaやPythonでも出てくる概念なので知っておくと他の言語を習得する際に役に立つかもしれません。

immutableについて一応説明しておきます

## 16

immutableというのは、作成したあとに変更ができないことをいいます。例えばクラスだと初期化以外のタイミングで状態の変更ができないことです。

immutableはその逆です。変更可能であるということです。さっきのスライドに出てきたクラスはmutableですね。

mutableだと勝手に中身を書き換えられてしまう恐れがあります。たとえば他のメソッドに値を渡した際などに書き換えられてしまうかもしれないですね

## 17

じゃあimmutableにしたいときどうすればいいかというと

値型の場合はletにするだけです。

参照型の場合はプロパティを初期化以外のタイミングで変更できなくするといいです。プロパティをletにしたり、computed propertyにしてgetだけ定義すればいいです

## 18

最後はOptionalについてです。

おそらくSwift学習者が一番つまずきやすいポイントなので、しっかり学習していきましょう。

## 19

Optional型って何かというと、nilが入るかもしれない型です

逆にOptionalじゃない型にはnilを入れることはできません。

nilはJavaでいうnullです。nullに対してメソッド呼び出ししようとしたらぬるぽで落ちますよね。

Objective-Cはnilに対してメソッド呼び出しをしても落ちません。なにもされません。

なにもされないのが期待動作ならまだしも、そうじゃなかったらnilかどうかチェックをしてあげる必要があります

でもnilチェックを忘れてしまうことがあります。Swiftなら忘れる心配はないです。

nilが入っている可能性のあるOptional型はそのまま使うことができないからです。中身を取り出すにはunwrapという処理が必要になります。

## 20

というわけでunwrapです

unwrapにはなんと5種類あるんです。

１個１個見ていきましょうか。

## 21

まずはForced Unwrapから

## 22

これは無理やりUnwrapするやりかたです

もし中身がnilのものをunwrapしたらクラッシュします。

なので中身がnilでない保証があるものに対して行うunwrapになります。

## 23

つぎはImplicity Unwrapped Optionalです

## 24

これは値を使う際に勝手にunwrapされるOptional型です

値を使う際にnilが入っていないことが保証されるような場合に使います

Optionalを定義するときに!マークで定義するとこの形になります

これはだいぶ使われるタイミングが限られていて、基本的にIBOutlet周りで使われています

クラスの初期化タイミングとインスタンスの初期化タイミングにずれがある場合に使われがちです

## 25

次はguard let文です

かなりお世話になると思います

## 26

guard let文はOptionalの中身がnilだったときに処理を抜けたい場合に使います。

ちなみに、else節にbreakかreturnを書かないとビルドエラーになるようになっています。

## 27

次はif let文です。

guard letと同じくらい使用頻度が多いような気がします。

## 28

これはOptionalの中身がnilかどうかで処理を分けたいときに使います。

## 29

最後です

## 30

??演算子を使ってもunwrapできます。

言葉で説明することが大変なのでコードを確認しましょう

## 31

終わりです