# 原稿 #3

## 01

やっと第三回ですね。

## 02

これで一通りやるべきことは終わりです。
最後のExtensionは知ってるのと知らないのとではSwiftらしいコードを書けるかどうかで違いが出てくると思います。

## 03

がんばりましょう

## 04

まずはクロージャについてです。

クロージャは、関数自体を変数として格納できる、関数自体をインスタンス化できる機能だと考えて大丈夫です。

じゃあこれ、何が嬉しいんでしょうか

## 05

クロージャは変数に代入がされた関数のインスタンスなので、すなわち

## 06

他のメソッドに引数としてクロージャを渡すことができるということです。

要は、処理自体を他のメソッドに渡す事ができるということです。

## 07

とりあえず例を何個か挙げておきます。

このhello関数は引数としてクロージャを受け取ることができます。

helloと表示したあとにクロージャを実行するように処理が組まれていますね。

このように、処理自体を他のメソッドに渡したい際にクロージャを使うことがあります。

じゃあ次は実際におみくじアプリで使用されている例を見ていきます。

## 08

これはおみくじアプリに実際に組み込まれている処理です。

アラートでOKボタンを押したあとの処理がクロージャで渡されています。

## 09

次はエラー処理です

ファイルを開いたり通信をする際には避けて通れないと思うので、これからやっていきましょう。

## 10

エラーを出すにはthrow文を使います。

throw文のあとに来るのはErrorプロトコルを実装した構造体や列挙体です

で、throwがされうるメソッドにはthrowsというキーワードを付ける必要があります。

とりあえずエラーの出し方はわかったので、次はエラーの処理のしかたです。

## 11

エラーの処理っていってもそのエラーの重要度に応じてアプローチを変える必要があると思います。

まあだいたい３種類のうちのどれかになると思います。

## 12

まず、エラーの種類によって場合分けしたい場合についてやっていきます

このときはdo-catch文を使います。

## 13

do-catch文で気をつけるべきことはいくつかあって、

まずはエラーが起きうる処理はdo節に書かないといけません。

その上で、エラーが起きうる処理を呼び出す処理を呼び出す際はtry文を前につけて呼び出さなくてはいけないです。

もしそこでエラーが発生したらcatch節に移ります。

## 14

たとえばこんな感じでエラーによって場合分けできたりします。

catchのあとにエラー種別をつけるとそのエラーが発生した時にだけ呼ばれるcatch節になります。

## 15

じゃあ次は、エラーが起きたかどうかだけにしか関心がない場合です

どういうエラーが起きたか知る必要がなくて、エラーが起きたらnilになればいいやっていう場合は、try?を使えます。

こいつはdo-catch文が要らないです。

## 16

try?を使うと戻り値がOptionalになるので、unwrapと一緒に使うパターンがよくあると思います。

この場合はif-let文と一緒に使っています。

## 17

最後はエラーが絶対に起きないと保証できるようなパターンです。

こういうシチュエーションがあるかはわかりません。

こういうときはtry!を使います。エラーが起きたらクラッシュします。

このときの戻り値はNon-Optionalなのでunwrapは不要です

## 18

たとえばこんな感じです。

戻り値はoptionalではないのでunwrapしていないことがわかります。


## 19

最後はExtensionです。

知らなくてもなんとかなりはしますが、Swiftらしいコードを書くためには避けて通れない機能です。

## 20

じゃあExtensionでできることについて説明していきたいと思います。

Extensionは既存のオブジェクトにに対する機能追加です。

ここでいうオブジェクトとは、クラスや構造体、列挙体やプロトコルのことです。

なにを追加できるかというと

メソッドの実装や、computed propertyなどです。

## 21

じゃあまずクラスや構造体、列挙体に対するExtensionを見ていきましょう。

## 22

たとえばこんな感じです。

ClassManクラスに対して新しいメソッドを追加しています。

なんだかありがたみがないので次の例に移ります。

## 23

この例は、おみくじアプリでの例を単純化したものです。

ここでのExtensionがなにをしているかというと、

既存のクラスにプロトコルを適合させています。

こんな感じで、プロトコルごとにExtensionで分けてコードの見通しを良くする目的でExtensionが使われることがよくあります。

## 24

最後、プロトコルに対するExtensionです。

Protocol Extensionと呼ばれてます。

プロトコルとは本来実装を持たないものなのですが、Extensionの力を借りると実装を持つことができるようになります。

## 25

じゃあ何がありがたいんでしょうか、

本来プロトコルは実装を持たないものですが、毎回毎回実装するのは面倒です。デフォルトの実装が決まっているなら実装わざわざ何度もやりたくないです。

デフォルトの実装をもたせたいときにProtocol Extensionは便利なんです。

Protocolはクラスと違って、1つの構造体やクラスに対して複数適用可能です。ということはProtocol Extensionのちからをフル活用すれば、クラスの継承の力をほとんど借りずにプログラミングができたりします

プロトコル志向プログラミングで調べたら色々と出てくると思います。

## 26

これで以上です。

ありがとうございました。
